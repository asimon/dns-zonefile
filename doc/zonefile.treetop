grammar Zonefile
  rule zone
    (variable / space_or_break / comment)* soa (resource_record / variable / comment / space / linebreak)* {
      def origin
        soa.origin.host.to_s
      end

      def to_s
        text_value
      end

      def rr
        elements[-1].elements.select { |e| e.to_s !~ /\A\s*([;$].*)?\z|\A\z/; }
      end
      
      def entries
        elements[0].elements.select { |e| e.to_s !~ /\A\s*(;.*)?\z|\A\z/; } +
          [soa] +
          elements[-1].elements.select { |e| e.to_s !~ /\A\s*(;.*)?\z|\A\z/; }
      end
    }
  end

  rule variable
    "$" name:([a-zA-Z0-9]+) space value:([a-zA-Z0-9\.\-_]+) space? comment? {
      def to_s
        "$#{name.text_value.to_s} #{value.text_value.to_s}"
      end

      def parse_type ; :variable ; end
    }
  end

  rule soa
    origin space ttl_and_klass "SOA" space ns space rp space "("? space_or_break* serial space_or_break refresh space_or_break reretry space_or_break expiry space_or_break nxttl space_or_break* ")"? {
      def to_s
        "#{origin} #{ttl} #{klass} SOA #{ns} #{rp} (#{serial} #{refresh} #{reretry} #{expiry} #{nxttl})"
      end

      def parse_type ; :soa ; end
      def ttl; ttl_and_klass.ttl; end
      def klass; ttl_and_klass.klass; end
    }
  end

  rule resource_record
    record:(
      a_record /
      aaaa_record /
      cname_record /
      mx_record /
      naptr_record /
      ns_record /
      ptr_record /
      srv_record /
      spf_record /
      txt_record /
      soa_record /
      x_mail_fwd_record /
      x_web_fwd_record
    ) ( space? comment )? linebreak {
      def zone
        p = parent
        while p.respond_to?(:parent) && p.parent
          p = p.parent
        end
        p
      end

      def to_s
        if respond_to?(:comment)
          "#{record} #{comment}"
        else
          record.to_s
        end
      end

      def record_type
        record.type.text_value.to_s
      end

      def ttl
        record.ttl_and_klass.ttl
      end

      def klass
        record.ttl_and_klass.klass
      end

      def method_missing(method_name, *args)
        if record.respond_to?(method_name)
          record.send(method_name, *args)
        end
      end

      def respond_to?(method_name)
        super || record.respond_to?(method_name)
      end

      def parse_type ; :record ; end
    }
  end

  rule a_record
    host space ttl_and_klass type:"A" space ip_address {
      def to_s
        "#{host} #{ttl_and_klass} A #{ip_address}"
      end
    }
  end

  rule ip_address
    [\d]+ "." [\d]+ "." [\d]+ "." [\d]+ {
      def to_s
        text_value
      end
    }
  end
  
  rule aaaa_record
    host space ttl_and_klass type:"AAAA" space ip_address:ip6_address {
      def to_s
        "#{host} #{ttl_and_klass} AAAA #{ip_address}"
      end
    }
  end
  
  rule ip6_address
    [\da-fA-F:.] 2..39 {
      def to_s
        text_value.downcase
      end
    }
  end

  rule cname_record
    host space ttl_and_klass type:"CNAME" space target:host {
      def to_s
        "#{host} #{ttl_and_klass} CNAME #{target}"
      end
    }
  end

  rule mx_record
    host space ttl_and_klass type:"MX" space priority:integer space exchanger:host {
      def to_s
        "#{host} #{ttl_and_klass} MX #{priority} #{exchanger}"
      end
    }
  end
  
  rule naptr_record
    host space ttl_and_klass type:"NAPTR" space data {
      def to_s
        "#{host} #{ttl_and_klass} NAPTR #{data}"
      end
    }
  end

  rule ns_record
    host space ttl_and_klass type:"NS" space nameserver:host {
      def to_s
        "#{host} #{ttl_and_klass} NS #{nameserver}"
      end
    }
  end

  rule ptr_record
    host space ttl_and_klass type:"PTR" space target:host {
      def to_s
        "#{host} #{ttl_and_klass} PTR #{target}"
      end
    }
  end

  rule soa_record
    origin space ttl_and_klass type:"SOA" space ns space rp space data {
      def to_s
        "#{origin} #{ttl_and_klass} SOA #{ns} #{rp} (#{data})"
      end
    }
  end

  rule srv_record
    host space ttl_and_klass type:"SRV" space priority:integer space weight:integer space port:integer space target:host {
      def to_s
        "#{host} #{ttl_and_klass} SRV #{priority} #{weight} #{port} #{target}"
      end
    }
  end
  
  rule spf_record
    host space ttl_and_klass type:"SPF" space data:txt_data {
      def to_s
        "#{host} #{ttl_and_klass} SPF #{data}"
      end
    }
  end
  
  rule txt_record
    host space ttl_and_klass type:"TXT" space data:txt_data {
      def to_s
        "#{host} #{ttl_and_klass} TXT #{data}"
      end
    }
  end

  # Pseudo-type to describe mail forwards.
  #
  # Instead of a host, expect a recipient, which is a "fully qualified mail
  # address", hopefully in the described zone.
  #
  # The targets are a comma-separated list of mail addresses.
  rule x_mail_fwd_record
    recipient:wildcard_mail_address space ttl_and_klass type:"X-MAIL-FWD" space targets:mail_address_list {
      def to_s
        "#{recipient} #{ttl_and_klass} X-MAIL-FWD #{targets}"
      end
    }
  end

  # Pseudo-type to decribe web forwardings.
  #
  # The "type" field describes the type of the forwarding, likely 301 or 302.
  #
  # The target is a URI.
  rule x_web_fwd_record
    host space ttl_and_klass type:"X-WEB-FWD" space fwtype:forward_type space target:http_uri {
      def to_s
        "#{host} #{ttl_and_klass} X-WEB-FWD #{fwtype} #{target}"
      end
    }
  end

  rule origin
    host comment* {
      def to_s
        "#{host}"
      end
    }
  end

  rule space
    [ \t]+ {
      def to_s
        ' '
      end
    }
  end
  
  rule linebreak
    [\n\r]+ {
      def to_s
        ''
      end
    }
  end
  
  rule space_or_break
    [\s]+ {
      def to_s
        text_value
      end
    }
  end

  rule klass
    "IN" {
      def to_s
        text_value
      end
    }
  end
  
  rule comment
    space* ";" [^\n\r]* {
      def to_s
        text_value.strip
      end
    }
  end

  rule ns
    host comment* {
      def to_s
        "#{host}"
      end
    }
  end

  rule rp
    (("\\." / [+a-zA-Z0-9\-)])+ ".")+ {
      def to_s
        text_value
      end
    }
  end

  rule serial
    integer comment* {
      def to_i
        integer.to_i
      end
      def to_s
        "#{to_i}"
      end
    }
  end

  rule time_interval
    integer time_multiplier {
      def to_s
        text_value
      end

      def to_i
        time_multiplier.to_i * integer.to_i
      end
    }
  end

  rule refresh
    time_interval comment* {
      def to_i
        time_interval.to_i
      end
      def to_s
        time_interval.to_s
      end
    }
  end

  rule integer
    [0-9]+ {
      def to_i
        text_value.to_i
      end
      def to_s
        "#{to_i}"
      end
    }
  end

  rule time_multiplier
    ( 's' / 'S' / 'm' / 'M' / 'h' / 'H' / 'd' / 'D' / 'w' / 'W' / '' ) {
      def to_s
        text_value
      end
      def to_i
        case text_value.downcase
          when 'm' then 60
          when 'h' then 60 * 60
          when 'd' then 60 * 60 * 24
          when 'w' then 60 * 60 * 24 * 7
          else
            1
        end
      end
    }
  end

  rule reretry
    time_interval comment* {
      def to_i
        time_interval.to_i
      end
      def to_s
        time_interval.to_s
      end
    }
  end

  rule expiry
    time_interval comment* {
      def to_i
        time_interval.to_i
      end
      def to_s
        time_interval.to_s
      end
    }
  end

  rule nxttl
    time_interval comment* {
      def to_i
        time_interval.to_i
      end
      def to_s
        time_interval.to_s
      end
    }
  end

  rule ttl_and_klass
    (
      time_interval space klass_part:klass space /
      klass_part:klass space time_interval space /
      time_interval space /
      klass_part:klass space /
      space?
    ) {
      def to_s
        [ttl, klass].compact.join(' ')
      end

      def ttl
        if respond_to?(:time_interval) && time_interval.text_value != ''
          time_interval.text_value
        else
          nil
        end
      end

      def klass
        respond_to?(:klass_part) ? klass_part.text_value : 'IN'
      end
    }
  end

  rule host
    ( hostname / wildcard_hostname / "@" / ' ' / "\t" ) {
      def to_s
        case text_value
        when /\.$/
          text_value
        when "@", /\s/
          text_value
        else
          text_value + '.@'
        end
      end
    }
  end

  # Allow a leading "*" label.
  rule wildcard_hostname
    ( ( hostname / '*' ) ( '.' hostname )? ) {
      def to_s
        text_value
      end
    }
  end

  rule hostname
    dns_label ( '.' dns_label )* '.'? {
      def to_s
        text_value
      end
    }
  end

  rule dns_label
    dns_label_char+ {
      def to_s
        text_value
      end
    }
  end

  # Keep this ambiguation around in case anyone wants to be correct about
  # the whole "two dashes in 3rd and 4th place" rule.
  rule dns_label_char
    ( '-' / dns_label_char_nodash ) {
      def to_s
        text_value
      end
    }
  end

  rule dns_label_char_nodash
    [a-zA-Z0-9_] {
      def to_s
        text_value
      end
    }
  end

  # Allow mail addresses that are catch-alls ("*" localpart) or "match"
  # multiple hosts by using a wildcard hostname.
  rule wildcard_mail_address
    ( "*" /  mail_localpart ) "@" exchange:wildcard_hostname {
      def to_s
        text_value
      end
    }
  end

  rule mail_address_list
    mail_address ( ',' mail_address )* {
      def to_s
        text_value
      end
    }
  end

  rule mail_address
    mail_localpart "@" exchange:hostname {
      def to_s
        text_value
      end
    }
  end

  rule mail_localpart
    ( [-+] / dns_label_char )+ {
      def to_s
        text_value
      end
    }
  end

  rule data
    [^;\n\r]+ {
      def to_s
        text_value.strip
      end
    }
  end

  rule txt_data
    '"'? ('\\"' / !'"' [^\n\r])* '"'? (space '"' ('\\"' / !'"' [^\n\r])* '"')* {
      def to_s
        text_value
      end
    }
  end

  rule forward_type
    ( "permanent" / "temporary" / "frame" ) {
      def to_s
        text_value
      end
    }
  end

  rule http_uri
    'http' [s]? '://' [^\s]+ {
      def to_s
        text_value
      end
    }
  end

end
