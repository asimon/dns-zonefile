require 'treetop'

module DNS
  module Zonefile
    # Autogenerated from a Treetop grammar. Edits may be lost.


    module ZonefileGrammar # :nodoc:
      include Treetop::Runtime

      def root
        @root ||= :zone
      end

      module Zone0
        def soa
          elements[1]
        end

      end

      module Zone1
        def origin
          soa.origin.host.to_s
        end

        def to_s
          text_value
        end

        def rr
          elements[-1].elements.select { |e| e.to_s !~ /\A\s*([;$].*)?\z|\A\z/; }
        end

        def entries
          elements[0].elements.select { |e| e.to_s !~ /\A\s*(;.*)?\z|\A\z/; } +
            [soa] +
            elements[-1].elements.select { |e| e.to_s !~ /\A\s*(;.*)?\z|\A\z/; }
        end
      end

      def _nt_zone
        start_index = index
        if node_cache[:zone].has_key?(index)
          cached = node_cache[:zone][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        s1, i1 = [], index
        loop do
          i2 = index
          r3 = _nt_variable
          if r3
            r2 = r3
          else
            r4 = _nt_space_or_break
            if r4
              r2 = r4
            else
              r5 = _nt_comment
              if r5
                r2 = r5
              else
                @index = i2
                r2 = nil
              end
            end
          end
          if r2
            s1 << r2
          else
            break
          end
        end
        r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        s0 << r1
        if r1
          r6 = _nt_soa
          s0 << r6
          if r6
            s7, i7 = [], index
            loop do
              i8 = index
              r9 = _nt_resource_record
              if r9
                r8 = r9
              else
                r10 = _nt_variable
                if r10
                  r8 = r10
                else
                  r11 = _nt_comment
                  if r11
                    r8 = r11
                  else
                    r12 = _nt_space
                    if r12
                      r8 = r12
                    else
                      r13 = _nt_linebreak
                      if r13
                        r8 = r13
                      else
                        @index = i8
                        r8 = nil
                      end
                    end
                  end
                end
              end
              if r8
                s7 << r8
              else
                break
              end
            end
            r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
            s0 << r7
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Zone0)
          r0.extend(Zone1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:zone][start_index] = r0

        r0
      end

      module Variable0
        def name
          elements[1]
        end

        def space
          elements[2]
        end

        def value
          elements[3]
        end

      end

      module Variable1
        def to_s
          "$#{name.text_value.to_s} #{value.text_value.to_s}"
        end

        def parse_type ; :variable ; end
      end

      def _nt_variable
        start_index = index
        if node_cache[:variable].has_key?(index)
          cached = node_cache[:variable][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?("$", false, index)
          r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure("$")
          r1 = nil
        end
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            if has_terminal?('\G[a-zA-Z0-9]', true, index)
              r3 = true
              @index += 1
            else
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          if s2.empty?
            @index = i2
            r2 = nil
          else
            r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          end
          s0 << r2
          if r2
            r4 = _nt_space
            s0 << r4
            if r4
              s5, i5 = [], index
              loop do
                if has_terminal?('\G[a-zA-Z0-9\\.\\-_]', true, index)
                  r6 = true
                  @index += 1
                else
                  r6 = nil
                end
                if r6
                  s5 << r6
                else
                  break
                end
              end
              if s5.empty?
                @index = i5
                r5 = nil
              else
                r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
              end
              s0 << r5
              if r5
                r8 = _nt_space
                if r8
                  r7 = r8
                else
                  r7 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r7
                if r7
                  r10 = _nt_comment
                  if r10
                    r9 = r10
                  else
                    r9 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r9
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Variable0)
          r0.extend(Variable1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:variable][start_index] = r0

        r0
      end

      module Soa0
        def origin
          elements[0]
        end

        def space1
          elements[1]
        end

        def ttl_and_klass
          elements[2]
        end

        def space2
          elements[4]
        end

        def ns
          elements[5]
        end

        def space3
          elements[6]
        end

        def rp
          elements[7]
        end

        def space4
          elements[8]
        end

        def serial
          elements[11]
        end

        def space_or_break1
          elements[12]
        end

        def refresh
          elements[13]
        end

        def space_or_break2
          elements[14]
        end

        def reretry
          elements[15]
        end

        def space_or_break3
          elements[16]
        end

        def expiry
          elements[17]
        end

        def space_or_break4
          elements[18]
        end

        def nxttl
          elements[19]
        end

      end

      module Soa1
        def to_s
          "#{origin} #{ttl} #{klass} SOA #{ns} #{rp} (#{serial} #{refresh} #{reretry} #{expiry} #{nxttl})"
        end

        def parse_type ; :soa ; end
        def ttl; ttl_and_klass.ttl; end
        def klass; ttl_and_klass.klass; end
      end

      def _nt_soa
        start_index = index
        if node_cache[:soa].has_key?(index)
          cached = node_cache[:soa][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_origin
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ttl_and_klass
            s0 << r3
            if r3
              if has_terminal?("SOA", false, index)
                r4 = instantiate_node(SyntaxNode,input, index...(index + 3))
                @index += 3
              else
                terminal_parse_failure("SOA")
                r4 = nil
              end
              s0 << r4
              if r4
                r5 = _nt_space
                s0 << r5
                if r5
                  r6 = _nt_ns
                  s0 << r6
                  if r6
                    r7 = _nt_space
                    s0 << r7
                    if r7
                      r8 = _nt_rp
                      s0 << r8
                      if r8
                        r9 = _nt_space
                        s0 << r9
                        if r9
                          if has_terminal?("(", false, index)
                            r11 = instantiate_node(SyntaxNode,input, index...(index + 1))
                            @index += 1
                          else
                            terminal_parse_failure("(")
                            r11 = nil
                          end
                          if r11
                            r10 = r11
                          else
                            r10 = instantiate_node(SyntaxNode,input, index...index)
                          end
                          s0 << r10
                          if r10
                            s12, i12 = [], index
                            loop do
                              r13 = _nt_space_or_break
                              if r13
                                s12 << r13
                              else
                                break
                              end
                            end
                            r12 = instantiate_node(SyntaxNode,input, i12...index, s12)
                            s0 << r12
                            if r12
                              r14 = _nt_serial
                              s0 << r14
                              if r14
                                r15 = _nt_space_or_break
                                s0 << r15
                                if r15
                                  r16 = _nt_refresh
                                  s0 << r16
                                  if r16
                                    r17 = _nt_space_or_break
                                    s0 << r17
                                    if r17
                                      r18 = _nt_reretry
                                      s0 << r18
                                      if r18
                                        r19 = _nt_space_or_break
                                        s0 << r19
                                        if r19
                                          r20 = _nt_expiry
                                          s0 << r20
                                          if r20
                                            r21 = _nt_space_or_break
                                            s0 << r21
                                            if r21
                                              r22 = _nt_nxttl
                                              s0 << r22
                                              if r22
                                                s23, i23 = [], index
                                                loop do
                                                  r24 = _nt_space_or_break
                                                  if r24
                                                    s23 << r24
                                                  else
                                                    break
                                                  end
                                                end
                                                r23 = instantiate_node(SyntaxNode,input, i23...index, s23)
                                                s0 << r23
                                                if r23
                                                  if has_terminal?(")", false, index)
                                                    r26 = instantiate_node(SyntaxNode,input, index...(index + 1))
                                                    @index += 1
                                                  else
                                                    terminal_parse_failure(")")
                                                    r26 = nil
                                                  end
                                                  if r26
                                                    r25 = r26
                                                  else
                                                    r25 = instantiate_node(SyntaxNode,input, index...index)
                                                  end
                                                  s0 << r25
                                                end
                                              end
                                            end
                                          end
                                        end
                                      end
                                    end
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Soa0)
          r0.extend(Soa1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:soa][start_index] = r0

        r0
      end

      module ResourceRecord0
        def comment
          elements[1]
        end
      end

      module ResourceRecord1
        def record
          elements[0]
        end

        def space_and_comment
          elements[1]
        end

        def linebreak
          elements[2]
        end
      end

      module ResourceRecord2
        def zone
          p = parent
          while p.respond_to?(:parent) && p.parent
            p = p.parent
          end
          p
        end

        def comment
          if space_and_comment.respond_to?(:comment)
    	  space_and_comment.comment.to_s
          end
        end

        def to_s
          if comment
            "#{record} #{comment}"
          else
            record.to_s
          end
        end

        def record_type
          record.type.text_value.to_s
        end

        def ttl
          record.ttl_and_klass.ttl
        end

        def klass
          record.ttl_and_klass.klass
        end

        def method_missing(method_name, *args)
          if record.respond_to?(method_name)
            record.send(method_name, *args)
          end
        end

        def respond_to?(method_name)
          super || record.respond_to?(method_name)
        end

        def parse_type ; :record ; end
      end

      def _nt_resource_record
        start_index = index
        if node_cache[:resource_record].has_key?(index)
          cached = node_cache[:resource_record][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        r2 = _nt_a_record
        if r2
          r1 = r2
        else
          r3 = _nt_aaaa_record
          if r3
            r1 = r3
          else
            r4 = _nt_cname_record
            if r4
              r1 = r4
            else
              r5 = _nt_mx_record
              if r5
                r1 = r5
              else
                r6 = _nt_naptr_record
                if r6
                  r1 = r6
                else
                  r7 = _nt_ns_record
                  if r7
                    r1 = r7
                  else
                    r8 = _nt_ptr_record
                    if r8
                      r1 = r8
                    else
                      r9 = _nt_srv_record
                      if r9
                        r1 = r9
                      else
                        r10 = _nt_spf_record
                        if r10
                          r1 = r10
                        else
                          r11 = _nt_txt_record
                          if r11
                            r1 = r11
                          else
                            r12 = _nt_soa_record
                            if r12
                              r1 = r12
                            else
                              r13 = _nt_x_mail_fwd_record
                              if r13
                                r1 = r13
                              else
                                r14 = _nt_x_web_fwd_record
                                if r14
                                  r1 = r14
                                else
                                  @index = i1
                                  r1 = nil
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        s0 << r1
        if r1
          i16, s16 = index, []
          r18 = _nt_space
          if r18
            r17 = r18
          else
            r17 = instantiate_node(SyntaxNode,input, index...index)
          end
          s16 << r17
          if r17
            r19 = _nt_comment
            s16 << r19
          end
          if s16.last
            r16 = instantiate_node(SyntaxNode,input, i16...index, s16)
            r16.extend(ResourceRecord0)
          else
            @index = i16
            r16 = nil
          end
          if r16
            r15 = r16
          else
            r15 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r15
          if r15
            r20 = _nt_linebreak
            s0 << r20
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ResourceRecord1)
          r0.extend(ResourceRecord2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:resource_record][start_index] = r0

        r0
      end

      module ARecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ttl_and_klass
          elements[2]
        end

        def type
          elements[3]
        end

        def space2
          elements[4]
        end

        def ip_address
          elements[5]
        end
      end

      module ARecord1
        def to_s
          "#{host} #{ttl_and_klass} A #{ip_address}"
        end
      end

      def _nt_a_record
        start_index = index
        if node_cache[:a_record].has_key?(index)
          cached = node_cache[:a_record][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ttl_and_klass
            s0 << r3
            if r3
              if has_terminal?("A", false, index)
                r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure("A")
                r4 = nil
              end
              s0 << r4
              if r4
                r5 = _nt_space
                s0 << r5
                if r5
                  r6 = _nt_ip_address
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ARecord0)
          r0.extend(ARecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:a_record][start_index] = r0

        r0
      end

      module IpAddress0
      end

      module IpAddress1
        def to_s
          text_value
        end
      end

      def _nt_ip_address
        start_index = index
        if node_cache[:ip_address].has_key?(index)
          cached = node_cache[:ip_address][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        s1, i1 = [], index
        loop do
          if has_terminal?('\G[\\d]', true, index)
            r2 = true
            @index += 1
          else
            r2 = nil
          end
          if r2
            s1 << r2
          else
            break
          end
        end
        if s1.empty?
          @index = i1
          r1 = nil
        else
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        end
        s0 << r1
        if r1
          if has_terminal?(".", false, index)
            r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure(".")
            r3 = nil
          end
          s0 << r3
          if r3
            s4, i4 = [], index
            loop do
              if has_terminal?('\G[\\d]', true, index)
                r5 = true
                @index += 1
              else
                r5 = nil
              end
              if r5
                s4 << r5
              else
                break
              end
            end
            if s4.empty?
              @index = i4
              r4 = nil
            else
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            end
            s0 << r4
            if r4
              if has_terminal?(".", false, index)
                r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure(".")
                r6 = nil
              end
              s0 << r6
              if r6
                s7, i7 = [], index
                loop do
                  if has_terminal?('\G[\\d]', true, index)
                    r8 = true
                    @index += 1
                  else
                    r8 = nil
                  end
                  if r8
                    s7 << r8
                  else
                    break
                  end
                end
                if s7.empty?
                  @index = i7
                  r7 = nil
                else
                  r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                end
                s0 << r7
                if r7
                  if has_terminal?(".", false, index)
                    r9 = instantiate_node(SyntaxNode,input, index...(index + 1))
                    @index += 1
                  else
                    terminal_parse_failure(".")
                    r9 = nil
                  end
                  s0 << r9
                  if r9
                    s10, i10 = [], index
                    loop do
                      if has_terminal?('\G[\\d]', true, index)
                        r11 = true
                        @index += 1
                      else
                        r11 = nil
                      end
                      if r11
                        s10 << r11
                      else
                        break
                      end
                    end
                    if s10.empty?
                      @index = i10
                      r10 = nil
                    else
                      r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                    end
                    s0 << r10
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(IpAddress0)
          r0.extend(IpAddress1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:ip_address][start_index] = r0

        r0
      end

      module AaaaRecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ttl_and_klass
          elements[2]
        end

        def type
          elements[3]
        end

        def space2
          elements[4]
        end

        def ip_address
          elements[5]
        end
      end

      module AaaaRecord1
        def to_s
          "#{host} #{ttl_and_klass} AAAA #{ip_address}"
        end
      end

      def _nt_aaaa_record
        start_index = index
        if node_cache[:aaaa_record].has_key?(index)
          cached = node_cache[:aaaa_record][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ttl_and_klass
            s0 << r3
            if r3
              if has_terminal?("AAAA", false, index)
                r4 = instantiate_node(SyntaxNode,input, index...(index + 4))
                @index += 4
              else
                terminal_parse_failure("AAAA")
                r4 = nil
              end
              s0 << r4
              if r4
                r5 = _nt_space
                s0 << r5
                if r5
                  r6 = _nt_ip6_address
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(AaaaRecord0)
          r0.extend(AaaaRecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:aaaa_record][start_index] = r0

        r0
      end

      module Ip6Address0
        def to_s
          text_value.downcase
        end
      end

      def _nt_ip6_address
        start_index = index
        if node_cache[:ip6_address].has_key?(index)
          cached = node_cache[:ip6_address][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          if has_terminal?('\G[\\da-fA-F:.]', true, index)
            r1 = true
            @index += 1
          else
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
          if s0.size == 39
            break
          end
        end
        if s0.size < 2
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Ip6Address0)
        end

        node_cache[:ip6_address][start_index] = r0

        r0
      end

      module CnameRecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ttl_and_klass
          elements[2]
        end

        def type
          elements[3]
        end

        def space2
          elements[4]
        end

        def target
          elements[5]
        end
      end

      module CnameRecord1
        def to_s
          "#{host} #{ttl_and_klass} CNAME #{target}"
        end
      end

      def _nt_cname_record
        start_index = index
        if node_cache[:cname_record].has_key?(index)
          cached = node_cache[:cname_record][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ttl_and_klass
            s0 << r3
            if r3
              if has_terminal?("CNAME", false, index)
                r4 = instantiate_node(SyntaxNode,input, index...(index + 5))
                @index += 5
              else
                terminal_parse_failure("CNAME")
                r4 = nil
              end
              s0 << r4
              if r4
                r5 = _nt_space
                s0 << r5
                if r5
                  r6 = _nt_host
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(CnameRecord0)
          r0.extend(CnameRecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:cname_record][start_index] = r0

        r0
      end

      module MxRecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ttl_and_klass
          elements[2]
        end

        def type
          elements[3]
        end

        def space2
          elements[4]
        end

        def priority
          elements[5]
        end

        def space3
          elements[6]
        end

        def exchanger
          elements[7]
        end
      end

      module MxRecord1
        def to_s
          "#{host} #{ttl_and_klass} MX #{priority} #{exchanger}"
        end
      end

      def _nt_mx_record
        start_index = index
        if node_cache[:mx_record].has_key?(index)
          cached = node_cache[:mx_record][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ttl_and_klass
            s0 << r3
            if r3
              if has_terminal?("MX", false, index)
                r4 = instantiate_node(SyntaxNode,input, index...(index + 2))
                @index += 2
              else
                terminal_parse_failure("MX")
                r4 = nil
              end
              s0 << r4
              if r4
                r5 = _nt_space
                s0 << r5
                if r5
                  r6 = _nt_integer
                  s0 << r6
                  if r6
                    r7 = _nt_space
                    s0 << r7
                    if r7
                      r8 = _nt_host
                      s0 << r8
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(MxRecord0)
          r0.extend(MxRecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:mx_record][start_index] = r0

        r0
      end

      module NaptrRecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ttl_and_klass
          elements[2]
        end

        def type
          elements[3]
        end

        def space2
          elements[4]
        end

        def data
          elements[5]
        end
      end

      module NaptrRecord1
        def to_s
          "#{host} #{ttl_and_klass} NAPTR #{data}"
        end
      end

      def _nt_naptr_record
        start_index = index
        if node_cache[:naptr_record].has_key?(index)
          cached = node_cache[:naptr_record][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ttl_and_klass
            s0 << r3
            if r3
              if has_terminal?("NAPTR", false, index)
                r4 = instantiate_node(SyntaxNode,input, index...(index + 5))
                @index += 5
              else
                terminal_parse_failure("NAPTR")
                r4 = nil
              end
              s0 << r4
              if r4
                r5 = _nt_space
                s0 << r5
                if r5
                  r6 = _nt_data
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(NaptrRecord0)
          r0.extend(NaptrRecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:naptr_record][start_index] = r0

        r0
      end

      module NsRecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ttl_and_klass
          elements[2]
        end

        def type
          elements[3]
        end

        def space2
          elements[4]
        end

        def nameserver
          elements[5]
        end
      end

      module NsRecord1
        def to_s
          "#{host} #{ttl_and_klass} NS #{nameserver}"
        end
      end

      def _nt_ns_record
        start_index = index
        if node_cache[:ns_record].has_key?(index)
          cached = node_cache[:ns_record][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ttl_and_klass
            s0 << r3
            if r3
              if has_terminal?("NS", false, index)
                r4 = instantiate_node(SyntaxNode,input, index...(index + 2))
                @index += 2
              else
                terminal_parse_failure("NS")
                r4 = nil
              end
              s0 << r4
              if r4
                r5 = _nt_space
                s0 << r5
                if r5
                  r6 = _nt_host
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(NsRecord0)
          r0.extend(NsRecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:ns_record][start_index] = r0

        r0
      end

      module PtrRecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ttl_and_klass
          elements[2]
        end

        def type
          elements[3]
        end

        def space2
          elements[4]
        end

        def target
          elements[5]
        end
      end

      module PtrRecord1
        def to_s
          "#{host} #{ttl_and_klass} PTR #{target}"
        end
      end

      def _nt_ptr_record
        start_index = index
        if node_cache[:ptr_record].has_key?(index)
          cached = node_cache[:ptr_record][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ttl_and_klass
            s0 << r3
            if r3
              if has_terminal?("PTR", false, index)
                r4 = instantiate_node(SyntaxNode,input, index...(index + 3))
                @index += 3
              else
                terminal_parse_failure("PTR")
                r4 = nil
              end
              s0 << r4
              if r4
                r5 = _nt_space
                s0 << r5
                if r5
                  r6 = _nt_host
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(PtrRecord0)
          r0.extend(PtrRecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:ptr_record][start_index] = r0

        r0
      end

      module SoaRecord0
        def origin
          elements[0]
        end

        def space1
          elements[1]
        end

        def ttl_and_klass
          elements[2]
        end

        def type
          elements[3]
        end

        def space2
          elements[4]
        end

        def ns
          elements[5]
        end

        def space3
          elements[6]
        end

        def rp
          elements[7]
        end

        def space4
          elements[8]
        end

        def data
          elements[9]
        end
      end

      module SoaRecord1
        def to_s
          "#{origin} #{ttl_and_klass} SOA #{ns} #{rp} (#{data})"
        end
      end

      def _nt_soa_record
        start_index = index
        if node_cache[:soa_record].has_key?(index)
          cached = node_cache[:soa_record][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_origin
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ttl_and_klass
            s0 << r3
            if r3
              if has_terminal?("SOA", false, index)
                r4 = instantiate_node(SyntaxNode,input, index...(index + 3))
                @index += 3
              else
                terminal_parse_failure("SOA")
                r4 = nil
              end
              s0 << r4
              if r4
                r5 = _nt_space
                s0 << r5
                if r5
                  r6 = _nt_ns
                  s0 << r6
                  if r6
                    r7 = _nt_space
                    s0 << r7
                    if r7
                      r8 = _nt_rp
                      s0 << r8
                      if r8
                        r9 = _nt_space
                        s0 << r9
                        if r9
                          r10 = _nt_data
                          s0 << r10
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SoaRecord0)
          r0.extend(SoaRecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:soa_record][start_index] = r0

        r0
      end

      module SrvRecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ttl_and_klass
          elements[2]
        end

        def type
          elements[3]
        end

        def space2
          elements[4]
        end

        def priority
          elements[5]
        end

        def space3
          elements[6]
        end

        def weight
          elements[7]
        end

        def space4
          elements[8]
        end

        def port
          elements[9]
        end

        def space5
          elements[10]
        end

        def target
          elements[11]
        end
      end

      module SrvRecord1
        def to_s
          "#{host} #{ttl_and_klass} SRV #{priority} #{weight} #{port} #{target}"
        end
      end

      def _nt_srv_record
        start_index = index
        if node_cache[:srv_record].has_key?(index)
          cached = node_cache[:srv_record][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ttl_and_klass
            s0 << r3
            if r3
              if has_terminal?("SRV", false, index)
                r4 = instantiate_node(SyntaxNode,input, index...(index + 3))
                @index += 3
              else
                terminal_parse_failure("SRV")
                r4 = nil
              end
              s0 << r4
              if r4
                r5 = _nt_space
                s0 << r5
                if r5
                  r6 = _nt_integer
                  s0 << r6
                  if r6
                    r7 = _nt_space
                    s0 << r7
                    if r7
                      r8 = _nt_integer
                      s0 << r8
                      if r8
                        r9 = _nt_space
                        s0 << r9
                        if r9
                          r10 = _nt_integer
                          s0 << r10
                          if r10
                            r11 = _nt_space
                            s0 << r11
                            if r11
                              r12 = _nt_host
                              s0 << r12
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SrvRecord0)
          r0.extend(SrvRecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:srv_record][start_index] = r0

        r0
      end

      module SpfRecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ttl_and_klass
          elements[2]
        end

        def type
          elements[3]
        end

        def space2
          elements[4]
        end

        def data
          elements[5]
        end
      end

      module SpfRecord1
        def to_s
          "#{host} #{ttl_and_klass} SPF #{data}"
        end
      end

      def _nt_spf_record
        start_index = index
        if node_cache[:spf_record].has_key?(index)
          cached = node_cache[:spf_record][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ttl_and_klass
            s0 << r3
            if r3
              if has_terminal?("SPF", false, index)
                r4 = instantiate_node(SyntaxNode,input, index...(index + 3))
                @index += 3
              else
                terminal_parse_failure("SPF")
                r4 = nil
              end
              s0 << r4
              if r4
                r5 = _nt_space
                s0 << r5
                if r5
                  r6 = _nt_txt_data
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SpfRecord0)
          r0.extend(SpfRecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:spf_record][start_index] = r0

        r0
      end

      module TxtRecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ttl_and_klass
          elements[2]
        end

        def type
          elements[3]
        end

        def space2
          elements[4]
        end

        def data
          elements[5]
        end
      end

      module TxtRecord1
        def to_s
          "#{host} #{ttl_and_klass} TXT #{data}"
        end
      end

      def _nt_txt_record
        start_index = index
        if node_cache[:txt_record].has_key?(index)
          cached = node_cache[:txt_record][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ttl_and_klass
            s0 << r3
            if r3
              if has_terminal?("TXT", false, index)
                r4 = instantiate_node(SyntaxNode,input, index...(index + 3))
                @index += 3
              else
                terminal_parse_failure("TXT")
                r4 = nil
              end
              s0 << r4
              if r4
                r5 = _nt_space
                s0 << r5
                if r5
                  r6 = _nt_txt_data
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(TxtRecord0)
          r0.extend(TxtRecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:txt_record][start_index] = r0

        r0
      end

      module XMailFwdRecord0
        def recipient
          elements[0]
        end

        def space1
          elements[1]
        end

        def ttl_and_klass
          elements[2]
        end

        def type
          elements[3]
        end

        def space2
          elements[4]
        end

        def targets
          elements[5]
        end
      end

      module XMailFwdRecord1
        def to_s
          "#{recipient} #{ttl_and_klass} X-MAIL-FWD #{targets}"
        end
      end

      def _nt_x_mail_fwd_record
        start_index = index
        if node_cache[:x_mail_fwd_record].has_key?(index)
          cached = node_cache[:x_mail_fwd_record][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_wildcard_mail_address
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ttl_and_klass
            s0 << r3
            if r3
              if has_terminal?("X-MAIL-FWD", false, index)
                r4 = instantiate_node(SyntaxNode,input, index...(index + 10))
                @index += 10
              else
                terminal_parse_failure("X-MAIL-FWD")
                r4 = nil
              end
              s0 << r4
              if r4
                r5 = _nt_space
                s0 << r5
                if r5
                  r6 = _nt_mail_address_list
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(XMailFwdRecord0)
          r0.extend(XMailFwdRecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:x_mail_fwd_record][start_index] = r0

        r0
      end

      module XWebFwdRecord0
        def host
          elements[0]
        end

        def space1
          elements[1]
        end

        def ttl_and_klass
          elements[2]
        end

        def type
          elements[3]
        end

        def space2
          elements[4]
        end

        def fwtype
          elements[5]
        end

        def space3
          elements[6]
        end

        def target
          elements[7]
        end
      end

      module XWebFwdRecord1
        def to_s
          "#{host} #{ttl_and_klass} X-WEB-FWD #{fwtype} #{target}"
        end
      end

      def _nt_x_web_fwd_record
        start_index = index
        if node_cache[:x_web_fwd_record].has_key?(index)
          cached = node_cache[:x_web_fwd_record][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
          if r2
            r3 = _nt_ttl_and_klass
            s0 << r3
            if r3
              if has_terminal?("X-WEB-FWD", false, index)
                r4 = instantiate_node(SyntaxNode,input, index...(index + 9))
                @index += 9
              else
                terminal_parse_failure("X-WEB-FWD")
                r4 = nil
              end
              s0 << r4
              if r4
                r5 = _nt_space
                s0 << r5
                if r5
                  r6 = _nt_forward_type
                  s0 << r6
                  if r6
                    r7 = _nt_space
                    s0 << r7
                    if r7
                      r8 = _nt_http_uri
                      s0 << r8
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(XWebFwdRecord0)
          r0.extend(XWebFwdRecord1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:x_web_fwd_record][start_index] = r0

        r0
      end

      module Origin0
        def host
          elements[0]
        end

      end

      module Origin1
        def to_s
          "#{host}"
        end
      end

      def _nt_origin
        start_index = index
        if node_cache[:origin].has_key?(index)
          cached = node_cache[:origin][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            r3 = _nt_comment
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Origin0)
          r0.extend(Origin1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:origin][start_index] = r0

        r0
      end

      module Space0
        def to_s
          ' '
        end
      end

      def _nt_space
        start_index = index
        if node_cache[:space].has_key?(index)
          cached = node_cache[:space][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          if has_terminal?('\G[ \\t]', true, index)
            r1 = true
            @index += 1
          else
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Space0)
        end

        node_cache[:space][start_index] = r0

        r0
      end

      module Linebreak0
        def to_s
          ''
        end
      end

      def _nt_linebreak
        start_index = index
        if node_cache[:linebreak].has_key?(index)
          cached = node_cache[:linebreak][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          if has_terminal?('\G[\\n\\r]', true, index)
            r1 = true
            @index += 1
          else
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Linebreak0)
        end

        node_cache[:linebreak][start_index] = r0

        r0
      end

      module SpaceOrBreak0
        def to_s
          text_value
        end
      end

      def _nt_space_or_break
        start_index = index
        if node_cache[:space_or_break].has_key?(index)
          cached = node_cache[:space_or_break][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          if has_terminal?('\G[\\s]', true, index)
            r1 = true
            @index += 1
          else
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SpaceOrBreak0)
        end

        node_cache[:space_or_break][start_index] = r0

        r0
      end

      module Klass0
        def to_s
          text_value
        end
      end

      def _nt_klass
        start_index = index
        if node_cache[:klass].has_key?(index)
          cached = node_cache[:klass][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if has_terminal?("IN", false, index)
          r0 = instantiate_node(SyntaxNode,input, index...(index + 2))
          r0.extend(Klass0)
          @index += 2
        else
          terminal_parse_failure("IN")
          r0 = nil
        end

        node_cache[:klass][start_index] = r0

        r0
      end

      module Comment0
      end

      module Comment1
        def to_s
          text_value.strip
        end
      end

      def _nt_comment
        start_index = index
        if node_cache[:comment].has_key?(index)
          cached = node_cache[:comment][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        s1, i1 = [], index
        loop do
          r2 = _nt_space
          if r2
            s1 << r2
          else
            break
          end
        end
        r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        s0 << r1
        if r1
          if has_terminal?(";", false, index)
            r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure(";")
            r3 = nil
          end
          s0 << r3
          if r3
            s4, i4 = [], index
            loop do
              if has_terminal?('\G[^\\n\\r]', true, index)
                r5 = true
                @index += 1
              else
                r5 = nil
              end
              if r5
                s4 << r5
              else
                break
              end
            end
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            s0 << r4
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Comment0)
          r0.extend(Comment1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:comment][start_index] = r0

        r0
      end

      module Ns0
        def host
          elements[0]
        end

      end

      module Ns1
        def to_s
          "#{host}"
        end
      end

      def _nt_ns
        start_index = index
        if node_cache[:ns].has_key?(index)
          cached = node_cache[:ns][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_host
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            r3 = _nt_comment
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Ns0)
          r0.extend(Ns1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:ns][start_index] = r0

        r0
      end

      module Rp0
      end

      module Rp1
        def to_s
          text_value
        end
      end

      def _nt_rp
        start_index = index
        if node_cache[:rp].has_key?(index)
          cached = node_cache[:rp][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          i1, s1 = index, []
          s2, i2 = [], index
          loop do
            i3 = index
            if has_terminal?("\\.", false, index)
              r4 = instantiate_node(SyntaxNode,input, index...(index + 2))
              @index += 2
            else
              terminal_parse_failure("\\.")
              r4 = nil
            end
            if r4
              r3 = r4
            else
              if has_terminal?('\G[+a-zA-Z0-9\\-)]', true, index)
                r5 = true
                @index += 1
              else
                r5 = nil
              end
              if r5
                r3 = r5
              else
                @index = i3
                r3 = nil
              end
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          if s2.empty?
            @index = i2
            r2 = nil
          else
            r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          end
          s1 << r2
          if r2
            if has_terminal?(".", false, index)
              r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure(".")
              r6 = nil
            end
            s1 << r6
          end
          if s1.last
            r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
            r1.extend(Rp0)
          else
            @index = i1
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Rp1)
        end

        node_cache[:rp][start_index] = r0

        r0
      end

      module Serial0
        def integer
          elements[0]
        end

      end

      module Serial1
        def to_i
          integer.to_i
        end
        def to_s
          "#{to_i}"
        end
      end

      def _nt_serial
        start_index = index
        if node_cache[:serial].has_key?(index)
          cached = node_cache[:serial][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_integer
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            r3 = _nt_comment
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Serial0)
          r0.extend(Serial1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:serial][start_index] = r0

        r0
      end

      module TimeInterval0
        def integer
          elements[0]
        end

        def time_multiplier
          elements[1]
        end
      end

      module TimeInterval1
        def to_s
          text_value
        end

        def to_i
          time_multiplier.to_i * integer.to_i
        end
      end

      def _nt_time_interval
        start_index = index
        if node_cache[:time_interval].has_key?(index)
          cached = node_cache[:time_interval][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_integer
        s0 << r1
        if r1
          r2 = _nt_time_multiplier
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(TimeInterval0)
          r0.extend(TimeInterval1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:time_interval][start_index] = r0

        r0
      end

      module Refresh0
        def time_interval
          elements[0]
        end

      end

      module Refresh1
        def to_i
          time_interval.to_i
        end
        def to_s
          time_interval.to_s
        end
      end

      def _nt_refresh
        start_index = index
        if node_cache[:refresh].has_key?(index)
          cached = node_cache[:refresh][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_time_interval
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            r3 = _nt_comment
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Refresh0)
          r0.extend(Refresh1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:refresh][start_index] = r0

        r0
      end

      module Integer0
        def to_i
          text_value.to_i
        end
        def to_s
          "#{to_i}"
        end
      end

      def _nt_integer
        start_index = index
        if node_cache[:integer].has_key?(index)
          cached = node_cache[:integer][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          if has_terminal?('\G[0-9]', true, index)
            r1 = true
            @index += 1
          else
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Integer0)
        end

        node_cache[:integer][start_index] = r0

        r0
      end

      module TimeMultiplier0
        def to_s
          text_value
        end
        def to_i
          case text_value.downcase
            when 'm' then 60
            when 'h' then 60 * 60
            when 'd' then 60 * 60 * 24
            when 'w' then 60 * 60 * 24 * 7
            else
              1
          end
        end
      end

      def _nt_time_multiplier
        start_index = index
        if node_cache[:time_multiplier].has_key?(index)
          cached = node_cache[:time_multiplier][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        if has_terminal?('s', false, index)
          r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('s')
          r1 = nil
        end
        if r1
          r0 = r1
          r0.extend(TimeMultiplier0)
        else
          if has_terminal?('S', false, index)
            r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('S')
            r2 = nil
          end
          if r2
            r0 = r2
            r0.extend(TimeMultiplier0)
          else
            if has_terminal?('m', false, index)
              r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure('m')
              r3 = nil
            end
            if r3
              r0 = r3
              r0.extend(TimeMultiplier0)
            else
              if has_terminal?('M', false, index)
                r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure('M')
                r4 = nil
              end
              if r4
                r0 = r4
                r0.extend(TimeMultiplier0)
              else
                if has_terminal?('h', false, index)
                  r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
                  @index += 1
                else
                  terminal_parse_failure('h')
                  r5 = nil
                end
                if r5
                  r0 = r5
                  r0.extend(TimeMultiplier0)
                else
                  if has_terminal?('H', false, index)
                    r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
                    @index += 1
                  else
                    terminal_parse_failure('H')
                    r6 = nil
                  end
                  if r6
                    r0 = r6
                    r0.extend(TimeMultiplier0)
                  else
                    if has_terminal?('d', false, index)
                      r7 = instantiate_node(SyntaxNode,input, index...(index + 1))
                      @index += 1
                    else
                      terminal_parse_failure('d')
                      r7 = nil
                    end
                    if r7
                      r0 = r7
                      r0.extend(TimeMultiplier0)
                    else
                      if has_terminal?('D', false, index)
                        r8 = instantiate_node(SyntaxNode,input, index...(index + 1))
                        @index += 1
                      else
                        terminal_parse_failure('D')
                        r8 = nil
                      end
                      if r8
                        r0 = r8
                        r0.extend(TimeMultiplier0)
                      else
                        if has_terminal?('w', false, index)
                          r9 = instantiate_node(SyntaxNode,input, index...(index + 1))
                          @index += 1
                        else
                          terminal_parse_failure('w')
                          r9 = nil
                        end
                        if r9
                          r0 = r9
                          r0.extend(TimeMultiplier0)
                        else
                          if has_terminal?('W', false, index)
                            r10 = instantiate_node(SyntaxNode,input, index...(index + 1))
                            @index += 1
                          else
                            terminal_parse_failure('W')
                            r10 = nil
                          end
                          if r10
                            r0 = r10
                            r0.extend(TimeMultiplier0)
                          else
                            if has_terminal?('', false, index)
                              r11 = instantiate_node(SyntaxNode,input, index...(index + 0))
                              @index += 0
                            else
                              terminal_parse_failure('')
                              r11 = nil
                            end
                            if r11
                              r0 = r11
                              r0.extend(TimeMultiplier0)
                            else
                              @index = i0
                              r0 = nil
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end

        node_cache[:time_multiplier][start_index] = r0

        r0
      end

      module Reretry0
        def time_interval
          elements[0]
        end

      end

      module Reretry1
        def to_i
          time_interval.to_i
        end
        def to_s
          time_interval.to_s
        end
      end

      def _nt_reretry
        start_index = index
        if node_cache[:reretry].has_key?(index)
          cached = node_cache[:reretry][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_time_interval
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            r3 = _nt_comment
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Reretry0)
          r0.extend(Reretry1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:reretry][start_index] = r0

        r0
      end

      module Expiry0
        def time_interval
          elements[0]
        end

      end

      module Expiry1
        def to_i
          time_interval.to_i
        end
        def to_s
          time_interval.to_s
        end
      end

      def _nt_expiry
        start_index = index
        if node_cache[:expiry].has_key?(index)
          cached = node_cache[:expiry][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_time_interval
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            r3 = _nt_comment
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Expiry0)
          r0.extend(Expiry1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:expiry][start_index] = r0

        r0
      end

      module Nxttl0
        def time_interval
          elements[0]
        end

      end

      module Nxttl1
        def to_i
          time_interval.to_i
        end
        def to_s
          time_interval.to_s
        end
      end

      def _nt_nxttl
        start_index = index
        if node_cache[:nxttl].has_key?(index)
          cached = node_cache[:nxttl][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_time_interval
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            r3 = _nt_comment
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Nxttl0)
          r0.extend(Nxttl1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:nxttl][start_index] = r0

        r0
      end

      module TtlAndKlass0
        def time_interval
          elements[0]
        end

        def space1
          elements[1]
        end

        def klass_part
          elements[2]
        end

        def space2
          elements[3]
        end
      end

      module TtlAndKlass1
        def klass_part
          elements[0]
        end

        def space1
          elements[1]
        end

        def time_interval
          elements[2]
        end

        def space2
          elements[3]
        end
      end

      module TtlAndKlass2
        def time_interval
          elements[0]
        end

        def space
          elements[1]
        end
      end

      module TtlAndKlass3
        def klass_part
          elements[0]
        end

        def space
          elements[1]
        end
      end

      module TtlAndKlass4
        def to_s
          [ttl, klass].compact.join(' ')
        end

        def ttl
          if respond_to?(:time_interval) && time_interval.text_value != ''
            time_interval.text_value
          else
            nil
          end
        end

        def klass
          respond_to?(:klass_part) ? klass_part.text_value : 'IN'
        end
      end

      def _nt_ttl_and_klass
        start_index = index
        if node_cache[:ttl_and_klass].has_key?(index)
          cached = node_cache[:ttl_and_klass][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_time_interval
        s1 << r2
        if r2
          r3 = _nt_space
          s1 << r3
          if r3
            r4 = _nt_klass
            s1 << r4
            if r4
              r5 = _nt_space
              s1 << r5
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(TtlAndKlass0)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r0 = r1
          r0.extend(TtlAndKlass4)
        else
          i6, s6 = index, []
          r7 = _nt_klass
          s6 << r7
          if r7
            r8 = _nt_space
            s6 << r8
            if r8
              r9 = _nt_time_interval
              s6 << r9
              if r9
                r10 = _nt_space
                s6 << r10
              end
            end
          end
          if s6.last
            r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
            r6.extend(TtlAndKlass1)
          else
            @index = i6
            r6 = nil
          end
          if r6
            r0 = r6
            r0.extend(TtlAndKlass4)
          else
            i11, s11 = index, []
            r12 = _nt_time_interval
            s11 << r12
            if r12
              r13 = _nt_space
              s11 << r13
            end
            if s11.last
              r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
              r11.extend(TtlAndKlass2)
            else
              @index = i11
              r11 = nil
            end
            if r11
              r0 = r11
              r0.extend(TtlAndKlass4)
            else
              i14, s14 = index, []
              r15 = _nt_klass
              s14 << r15
              if r15
                r16 = _nt_space
                s14 << r16
              end
              if s14.last
                r14 = instantiate_node(SyntaxNode,input, i14...index, s14)
                r14.extend(TtlAndKlass3)
              else
                @index = i14
                r14 = nil
              end
              if r14
                r0 = r14
                r0.extend(TtlAndKlass4)
              else
                r18 = _nt_space
                if r18
                  r17 = r18
                else
                  r17 = instantiate_node(SyntaxNode,input, index...index)
                end
                if r17
                  r0 = r17
                  r0.extend(TtlAndKlass4)
                else
                  @index = i0
                  r0 = nil
                end
              end
            end
          end
        end

        node_cache[:ttl_and_klass][start_index] = r0

        r0
      end

      module Host0
        def to_s
          case text_value
          when /\.$/
            text_value
          when "@", /\s/
            text_value
          else
            text_value + '.@'
          end
        end
      end

      def _nt_host
        start_index = index
        if node_cache[:host].has_key?(index)
          cached = node_cache[:host][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_hostname
        if r1
          r0 = r1
          r0.extend(Host0)
        else
          r2 = _nt_wildcard_hostname
          if r2
            r0 = r2
            r0.extend(Host0)
          else
            if has_terminal?("@", false, index)
              r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure("@")
              r3 = nil
            end
            if r3
              r0 = r3
              r0.extend(Host0)
            else
              if has_terminal?(' ', false, index)
                r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure(' ')
                r4 = nil
              end
              if r4
                r0 = r4
                r0.extend(Host0)
              else
                if has_terminal?("\t", false, index)
                  r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
                  @index += 1
                else
                  terminal_parse_failure("\t")
                  r5 = nil
                end
                if r5
                  r0 = r5
                  r0.extend(Host0)
                else
                  @index = i0
                  r0 = nil
                end
              end
            end
          end
        end

        node_cache[:host][start_index] = r0

        r0
      end

      module WildcardHostname0
        def hostname
          elements[1]
        end
      end

      module WildcardHostname1
      end

      module WildcardHostname2
        def to_s
          text_value
        end
      end

      def _nt_wildcard_hostname
        start_index = index
        if node_cache[:wildcard_hostname].has_key?(index)
          cached = node_cache[:wildcard_hostname][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        i2 = index
        r3 = _nt_hostname
        if r3
          r2 = r3
        else
          if has_terminal?('*', false, index)
            r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('*')
            r4 = nil
          end
          if r4
            r2 = r4
          else
            @index = i2
            r2 = nil
          end
        end
        s1 << r2
        if r2
          i6, s6 = index, []
          if has_terminal?('.', false, index)
            r7 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('.')
            r7 = nil
          end
          s6 << r7
          if r7
            r8 = _nt_hostname
            s6 << r8
          end
          if s6.last
            r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
            r6.extend(WildcardHostname0)
          else
            @index = i6
            r6 = nil
          end
          if r6
            r5 = r6
          else
            r5 = instantiate_node(SyntaxNode,input, index...index)
          end
          s1 << r5
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(WildcardHostname1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r0 = r1
          r0.extend(WildcardHostname2)
        else
          if has_terminal?("@", false, index)
            r9 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure("@")
            r9 = nil
          end
          if r9
            r0 = r9
            r0.extend(WildcardHostname2)
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:wildcard_hostname][start_index] = r0

        r0
      end

      module Hostname0
        def dns_label
          elements[1]
        end
      end

      module Hostname1
        def dns_label
          elements[0]
        end

      end

      module Hostname2
        def to_s
          text_value
        end
      end

      def _nt_hostname
        start_index = index
        if node_cache[:hostname].has_key?(index)
          cached = node_cache[:hostname][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_dns_label
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3, s3 = index, []
            if has_terminal?('.', false, index)
              r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure('.')
              r4 = nil
            end
            s3 << r4
            if r4
              r5 = _nt_dns_label
              s3 << r5
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(Hostname0)
            else
              @index = i3
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
          if r2
            if has_terminal?('.', false, index)
              r7 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure('.')
              r7 = nil
            end
            if r7
              r6 = r7
            else
              r6 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r6
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Hostname1)
          r0.extend(Hostname2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:hostname][start_index] = r0

        r0
      end

      module DnsLabel0
        def to_s
          text_value
        end
      end

      def _nt_dns_label
        start_index = index
        if node_cache[:dns_label].has_key?(index)
          cached = node_cache[:dns_label][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          r1 = _nt_dns_label_char
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DnsLabel0)
        end

        node_cache[:dns_label][start_index] = r0

        r0
      end

      module DnsLabelChar0
        def to_s
          text_value
        end
      end

      def _nt_dns_label_char
        start_index = index
        if node_cache[:dns_label_char].has_key?(index)
          cached = node_cache[:dns_label_char][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        if has_terminal?('-', false, index)
          r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('-')
          r1 = nil
        end
        if r1
          r0 = r1
          r0.extend(DnsLabelChar0)
        else
          r2 = _nt_dns_label_char_nodash
          if r2
            r0 = r2
            r0.extend(DnsLabelChar0)
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:dns_label_char][start_index] = r0

        r0
      end

      module DnsLabelCharNodash0
        def to_s
          text_value
        end
      end

      def _nt_dns_label_char_nodash
        start_index = index
        if node_cache[:dns_label_char_nodash].has_key?(index)
          cached = node_cache[:dns_label_char_nodash][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if has_terminal?('\G[a-zA-Z0-9_]', true, index)
          r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
          r0.extend(DnsLabelCharNodash0)
          @index += 1
        else
          r0 = nil
        end

        node_cache[:dns_label_char_nodash][start_index] = r0

        r0
      end

      module WildcardMailAddress0
        def exchange
          elements[2]
        end
      end

      module WildcardMailAddress1
        def to_s
          text_value
        end
      end

      def _nt_wildcard_mail_address
        start_index = index
        if node_cache[:wildcard_mail_address].has_key?(index)
          cached = node_cache[:wildcard_mail_address][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        if has_terminal?("*", false, index)
          r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure("*")
          r2 = nil
        end
        if r2
          r1 = r2
        else
          r3 = _nt_mail_localpart
          if r3
            r1 = r3
          else
            @index = i1
            r1 = nil
          end
        end
        s0 << r1
        if r1
          if has_terminal?("@", false, index)
            r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure("@")
            r4 = nil
          end
          s0 << r4
          if r4
            r6 = _nt_wildcard_hostname
            if r6
              r5 = r6
            else
              r5 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r5
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(WildcardMailAddress0)
          r0.extend(WildcardMailAddress1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:wildcard_mail_address][start_index] = r0

        r0
      end

      module MailAddressList0
        def mail_address
          elements[1]
        end
      end

      module MailAddressList1
        def mail_address
          elements[0]
        end

      end

      module MailAddressList2
        def to_s
          text_value
        end
      end

      def _nt_mail_address_list
        start_index = index
        if node_cache[:mail_address_list].has_key?(index)
          cached = node_cache[:mail_address_list][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_mail_address
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3, s3 = index, []
            if has_terminal?(',', false, index)
              r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure(',')
              r4 = nil
            end
            s3 << r4
            if r4
              r5 = _nt_mail_address
              s3 << r5
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(MailAddressList0)
            else
              @index = i3
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(MailAddressList1)
          r0.extend(MailAddressList2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:mail_address_list][start_index] = r0

        r0
      end

      module MailAddress0
        def mail_localpart
          elements[0]
        end

        def exchange
          elements[2]
        end
      end

      module MailAddress1
        def to_s
          text_value
        end
      end

      def _nt_mail_address
        start_index = index
        if node_cache[:mail_address].has_key?(index)
          cached = node_cache[:mail_address][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_mail_localpart
        s0 << r1
        if r1
          if has_terminal?("@", false, index)
            r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure("@")
            r2 = nil
          end
          s0 << r2
          if r2
            r3 = _nt_hostname
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(MailAddress0)
          r0.extend(MailAddress1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:mail_address][start_index] = r0

        r0
      end

      module MailLocalpart0
        def to_s
          text_value
        end
      end

      def _nt_mail_localpart
        start_index = index
        if node_cache[:mail_localpart].has_key?(index)
          cached = node_cache[:mail_localpart][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          i1 = index
          if has_terminal?('\G[-+]', true, index)
            r2 = true
            @index += 1
          else
            r2 = nil
          end
          if r2
            r1 = r2
          else
            r3 = _nt_dns_label_char
            if r3
              r1 = r3
            else
              @index = i1
              r1 = nil
            end
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(MailLocalpart0)
        end

        node_cache[:mail_localpart][start_index] = r0

        r0
      end

      module Data0
        def to_s
          text_value.strip
        end
      end

      def _nt_data
        start_index = index
        if node_cache[:data].has_key?(index)
          cached = node_cache[:data][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          if has_terminal?('\G[^;\\n\\r]', true, index)
            r1 = true
            @index += 1
          else
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Data0)
        end

        node_cache[:data][start_index] = r0

        r0
      end

      module TxtData0
      end

      module TxtData1
      end

      module TxtData2
        def space
          elements[0]
        end

      end

      module TxtData3
      end

      module TxtData4
        def to_s
          text_value
        end
      end

      def _nt_txt_data
        start_index = index
        if node_cache[:txt_data].has_key?(index)
          cached = node_cache[:txt_data][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?('"', false, index)
          r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('"')
          r2 = nil
        end
        if r2
          r1 = r2
        else
          r1 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r1
        if r1
          s3, i3 = [], index
          loop do
            i4 = index
            if has_terminal?('\\"', false, index)
              r5 = instantiate_node(SyntaxNode,input, index...(index + 2))
              @index += 2
            else
              terminal_parse_failure('\\"')
              r5 = nil
            end
            if r5
              r4 = r5
            else
              i6, s6 = index, []
              i7 = index
              if has_terminal?('"', false, index)
                r8 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure('"')
                r8 = nil
              end
              if r8
                r7 = nil
              else
                @index = i7
                r7 = instantiate_node(SyntaxNode,input, index...index)
              end
              s6 << r7
              if r7
                if has_terminal?('\G[^\\n\\r]', true, index)
                  r9 = true
                  @index += 1
                else
                  r9 = nil
                end
                s6 << r9
              end
              if s6.last
                r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
                r6.extend(TxtData0)
              else
                @index = i6
                r6 = nil
              end
              if r6
                r4 = r6
              else
                @index = i4
                r4 = nil
              end
            end
            if r4
              s3 << r4
            else
              break
            end
          end
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          s0 << r3
          if r3
            if has_terminal?('"', false, index)
              r11 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure('"')
              r11 = nil
            end
            if r11
              r10 = r11
            else
              r10 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r10
            if r10
              s12, i12 = [], index
              loop do
                i13, s13 = index, []
                r14 = _nt_space
                s13 << r14
                if r14
                  if has_terminal?('"', false, index)
                    r15 = instantiate_node(SyntaxNode,input, index...(index + 1))
                    @index += 1
                  else
                    terminal_parse_failure('"')
                    r15 = nil
                  end
                  s13 << r15
                  if r15
                    s16, i16 = [], index
                    loop do
                      i17 = index
                      if has_terminal?('\\"', false, index)
                        r18 = instantiate_node(SyntaxNode,input, index...(index + 2))
                        @index += 2
                      else
                        terminal_parse_failure('\\"')
                        r18 = nil
                      end
                      if r18
                        r17 = r18
                      else
                        i19, s19 = index, []
                        i20 = index
                        if has_terminal?('"', false, index)
                          r21 = instantiate_node(SyntaxNode,input, index...(index + 1))
                          @index += 1
                        else
                          terminal_parse_failure('"')
                          r21 = nil
                        end
                        if r21
                          r20 = nil
                        else
                          @index = i20
                          r20 = instantiate_node(SyntaxNode,input, index...index)
                        end
                        s19 << r20
                        if r20
                          if has_terminal?('\G[^\\n\\r]', true, index)
                            r22 = true
                            @index += 1
                          else
                            r22 = nil
                          end
                          s19 << r22
                        end
                        if s19.last
                          r19 = instantiate_node(SyntaxNode,input, i19...index, s19)
                          r19.extend(TxtData1)
                        else
                          @index = i19
                          r19 = nil
                        end
                        if r19
                          r17 = r19
                        else
                          @index = i17
                          r17 = nil
                        end
                      end
                      if r17
                        s16 << r17
                      else
                        break
                      end
                    end
                    r16 = instantiate_node(SyntaxNode,input, i16...index, s16)
                    s13 << r16
                    if r16
                      if has_terminal?('"', false, index)
                        r23 = instantiate_node(SyntaxNode,input, index...(index + 1))
                        @index += 1
                      else
                        terminal_parse_failure('"')
                        r23 = nil
                      end
                      s13 << r23
                    end
                  end
                end
                if s13.last
                  r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
                  r13.extend(TxtData2)
                else
                  @index = i13
                  r13 = nil
                end
                if r13
                  s12 << r13
                else
                  break
                end
              end
              r12 = instantiate_node(SyntaxNode,input, i12...index, s12)
              s0 << r12
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(TxtData3)
          r0.extend(TxtData4)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:txt_data][start_index] = r0

        r0
      end

      module ForwardType0
        def to_s
          text_value
        end
      end

      def _nt_forward_type
        start_index = index
        if node_cache[:forward_type].has_key?(index)
          cached = node_cache[:forward_type][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        if has_terminal?("permanent", false, index)
          r1 = instantiate_node(SyntaxNode,input, index...(index + 9))
          @index += 9
        else
          terminal_parse_failure("permanent")
          r1 = nil
        end
        if r1
          r0 = r1
          r0.extend(ForwardType0)
        else
          if has_terminal?("temporary", false, index)
            r2 = instantiate_node(SyntaxNode,input, index...(index + 9))
            @index += 9
          else
            terminal_parse_failure("temporary")
            r2 = nil
          end
          if r2
            r0 = r2
            r0.extend(ForwardType0)
          else
            if has_terminal?("frame", false, index)
              r3 = instantiate_node(SyntaxNode,input, index...(index + 5))
              @index += 5
            else
              terminal_parse_failure("frame")
              r3 = nil
            end
            if r3
              r0 = r3
              r0.extend(ForwardType0)
            else
              @index = i0
              r0 = nil
            end
          end
        end

        node_cache[:forward_type][start_index] = r0

        r0
      end

      module HttpUri0
      end

      module HttpUri1
        def to_s
          text_value
        end
      end

      def _nt_http_uri
        start_index = index
        if node_cache[:http_uri].has_key?(index)
          cached = node_cache[:http_uri][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?('http', false, index)
          r1 = instantiate_node(SyntaxNode,input, index...(index + 4))
          @index += 4
        else
          terminal_parse_failure('http')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?('\G[s]', true, index)
            r3 = true
            @index += 1
          else
            r3 = nil
          end
          if r3
            r2 = r3
          else
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
          if r2
            if has_terminal?('://', false, index)
              r4 = instantiate_node(SyntaxNode,input, index...(index + 3))
              @index += 3
            else
              terminal_parse_failure('://')
              r4 = nil
            end
            s0 << r4
            if r4
              s5, i5 = [], index
              loop do
                if has_terminal?('\G[^\\s]', true, index)
                  r6 = true
                  @index += 1
                else
                  r6 = nil
                end
                if r6
                  s5 << r6
                else
                  break
                end
              end
              if s5.empty?
                @index = i5
                r5 = nil
              else
                r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
              end
              s0 << r5
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(HttpUri0)
          r0.extend(HttpUri1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:http_uri][start_index] = r0

        r0
      end

    end

    class Parser < Treetop::Runtime::CompiledParser
      include ZonefileGrammar # :nodoc:
    end
  end
end